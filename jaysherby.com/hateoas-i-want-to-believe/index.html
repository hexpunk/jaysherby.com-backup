<!DOCTYPE html>
<html lang="en">

<head>
  
  
  
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5"/>
  
  <title>HATEOAS: I want to believe | Jay&#x27;s blog</title>
  <link rel="canonical" href="index.html" />
  


<meta name="jaysherby" content="look-for-the-bear-necessities"/>

<!-- Primary Meta Tags -->
<meta name="title" content="HATEOAS: I want to believe">
<meta name="description" content="There&#x27;s a growing voice in the web dev community. I&#x27;m going to call them &quot;web fundamentalists&quot;. They hold certain beliefs about web development.

Single-page...">

<!-- Open Graph / Facebook -->
<meta property="og:site_name" content="Jay&#x27;s blog">
<meta property="og:title" content="HATEOAS: I want to believe">
<meta property="og:type" content="article">
<meta property="og:url" content="https://jaysherby.com/hateoas-i-want-to-believe/">
<meta property="og:description" content="There&#x27;s a growing voice in the web dev community. I&#x27;m going to call them &quot;web fundamentalists&quot;. They hold certain beliefs about web development.

Single-page...">


<!-- Twitter -->
<meta property="twitter:card" content="summary">
<meta property="twitter:url" content="https://jaysherby.com/hateoas-i-want-to-believe/">
<meta property="twitter:title" content="HATEOAS: I want to believe">
<meta property="twitter:description" content="There&#x27;s a growing voice in the web dev community. I&#x27;m going to call them &quot;web fundamentalists&quot;. They hold certain beliefs about web development.

Single-page...">



<!-- Microdata -->
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "article",
    "name": "HATEOAS: I want to believe",
    "url": "https://jaysherby.com/hateoas-i-want-to-believe/",
    "description": "There&#x27;s a growing voice in the web dev community. I&#x27;m going to call them &quot;web fundamentalists&quot;. They hold certain beliefs about web development.

Single-page...",
    "about": {
      "@type": "HATEOAS: I want to believe",
      "description": "There&#x27;s a growing voice in the web dev community. I&#x27;m going to call them &quot;web fundamentalists&quot;. They hold certain beliefs about web development.

Single-page..."
    }
  }
</script>

  






<link rel="stylesheet" href="../static/pygmentify/css/default.min.css">

  
  <link rel="shortcut icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üë®‚Äçüíª</text></svg>">

  <style>
      
      
      :root {
    --width: 800px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color:  #8b6fcb;
    --code-background-color: #f2f2f2;
    --code-color: #222;
    --blockquote-color: #222;
}

@media (prefers-color-scheme: dark) {
    :root {
        --background-color: #01242e;
        --heading-color: #eee;
        --text-color: #ddd;
        --link-color: #8cc2dd;
        --visited-color:  #8b6fcb;
        --code-background-color: #000;
        --code-color: #ddd;
        --blockquote-color: #ccc;
    }
}

body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
}

h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
}

a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
}

a:hover {
    text-decoration: underline; 
}

nav a {
    margin-right: 8px;
}

strong, b {
    color: var(--heading-color);
}

button {
    margin: 0;
    cursor: pointer;
}

content {
    line-height: 1.6;
}

table {
    width: 100%;
}

hr {
    border: 0;
    border-top: 1px dashed;
}

img {
    max-width: 100%;
}

code {
    font-family: monospace;
    padding: 2px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
}

blockquote {
    border-left: 1px solid #999;
    color: var(--code-color);
    padding-left: 20px;
    font-style: italic;
}

footer {
    padding: 25px 0;
    text-align: center;
}

.title:hover {
    text-decoration: none;
}

.title h1 {
    font-size: 1.5em;
}

.inline {
    width: auto !important;
}

.highlight, .code {
    padding: 1px 15px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
}

/* blog post list */
ul.blog-posts {
    list-style-type: none;
    padding: unset;
}

ul.blog-posts li {
    display: flex;
}

ul.blog-posts li span {
    flex: 0 0 130px;
}

ul.blog-posts li a:visited {
    color: var(--visited-color);
}
blockquote.me,
blockquote.them {
  border: 0;
  box-shadow: 4px 4px 16px rgba(0, 0, 0, 0.3);
  font: inherit;
  padding: 0 16px;
  
  /* Prevent margin collapse */
  overflow: hidden;
}

blockquote.me::before,
blockquote.them::before {
  float: left;
  margin: 16px 8px 0 0;
}

blockquote.me {
  background-color: #1e3a8a;
  border-radius: 10px 10px 0 10px;
  color: #ddd;
  margin: 20px 0 20px 20%;
}

blockquote.me::before {
  content: "üë®‚Äçüíª";
}

blockquote.them {
  background-color: #e5e7eb;
  border-radius: 10px 10px 10px 0;
  color: #444;
  margin: 20px 20% 20px 0;
}

blockquote.them::before {
  content: "ü§ñ";
}

blockquote.me p,
blockquote.them p {
  white-space: pre-wrap;
}

blockquote.me strong,
blockquote.them strong {
  color: inherit;
}

content img {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

details > summary {
  cursor: pointer;
}

body {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  padding: 0 20px;
}

header {
  padding-top: 20px;
}

main {
  flex-grow: 1;
}
      
  </style>
</head>

<body class="post ">
  <header>
    <a class="title" href="../index.html">
      <h1>
        
        Jay&#x27;s blog
      </h1>
    </a>
    <nav>
      <p><a href="../index.html">Home</a> <a href="../blog/index.html">Blog</a></p>

    </nav>
  </header>
  <main>
    





<h1>
    HATEOAS: I want to believe
</h1>

<p>
    <i>
        <time datetime="2023-05-16" pubdate>
            16 May, 2023
        </time>
    </i>
</p>


<content>
<p>There's a growing voice in the web dev community. I'm going to call them "web fundamentalists". They hold certain beliefs about web development.</p>
<ul>
<li>Single-page apps (SPAs) make for a poor user experience.</li>
<li>SPAs are bad for accessibility.</li>
<li>Good APIs make semantically correct use of more of the HTTP verbs than just GET and POST.</li>
<li>It's okay for an application server to return HTML.</li>
<li>The web should be generally usable with JavaScript disabled.</li>
<li>Cookie-based sessions are better than JSON Web Tokens.</li>
<li>JavaScript doesn't need a compiler.</li>
<li>A web API that accepts and returns JSON isn't necessarily REST.</li>
<li>Web applications should be offline-first.</li>
<li>Accessibility encompasses more than assistive technologies. An accessible application is tolerant of old hardware, old software, and poor connectivity.</li>
<li>Boring tech makes for reliable tech.</li>
<li>Progressive enhancement is better than graceful degradation, but both are better than nothing at all.</li>
</ul>
<p>I agree with most, if not all, of these beliefs, in principle. However, I find that many of these beliefs are often overly idealistic and can fall apart when theory meets practice.</p>
<h2 id="uphill-both-ways">Uphill both ways</h2>
<p>Just like many forms of fundamentalism, this form is probably influenced by how quickly and drastically change has occurred. Web development looks completely different today than it did 10 years ago. In a rapidly changing environment, it's easy to fall prey to rose-tinted nostalgia.</p>
<p>I remember when a web application generated all of a page's HTML on the server side. Slowly but surely, more and more logic would find its way into the templates. This was bad because template logic was generally slower than non-template logic. I have worked on applications where more than half of a server request's time was spent rendering the HTML. It was a bad time. In the short term, people started pushing so-called "logic-less templates". <a href="https://en.wikipedia.org/wiki/Mustache_%28template_system%29">Mustache templates</a> became the new hotness.</p>
<p>Longer term, the prevailing wisdom was that we needed to stop treating web browsers like thin clients. Can you believe there was ever any doubt? Web browsers are the thickest of thick clients. The web browser is the new operating system. Look at Chromebooks! People gladly buy laptops that can only run a glorified web browser.</p>
<p>If more than half of your server's workload is building HTML, basically shuffling strings around, you're paying to do something your client's devices are capable of doing on your behalf. Plus, there's so much redundant data going over the wire. You're sending your web app's navigation code for every page request. Ideally, you should amortize the templating and rendering by making your users' devices handle it. Your server doesn't have to do it, so you don't have to pay for the computer time or the data transfer.</p>
<p>I was there at the time and this made perfect sense. Your server only has to deal in pure data and your front-end code only needs to worry about displaying that data and performing server requests. This is what led to REST APIs and SPAs.</p>
<p>But modern solutions call for modern problems and now we have to care about the efficiency with which data is represented and queried. None of that mattered previously because it all happened on the server. Your browser requested one whole page and the server returned one whole page. Since accessing the data and applying it to a template was essentially a single task accomplished by a single program running on a single machine, tightly coupling them wasn't a big deal.</p>
<p>With SPAs, you're encouraged to think of your server and your front-end as two different programs that happen to talk to one another. Wouldn't it be nice if your data representation wasn't tied to any particular display format? Your data is its own platonic ideal of entities and relationships, not all that different from a database. In fact, your application server isn't much more than a thin wrapper around your database. The only extra stuff it needs to do is authentication, authorization, data serialization (into JSON, the web's data serialization format of choice), and some data validation that's more application-specific than you can probably represent in a database alone.</p>
<h2 id="r-e-s-t-find-out-what-it-means-to-me">R-E-S-T, find out what it means to me</h2>
<p>Representational state transfer, or REST, was the solution for what protocol the web was going to standardize on for this new world of front-ends and back-ends. Almost.</p>
<p>REST, at its heart, is basically a remote procedure call interface that plays to the strengths of the web's existing technology. Specifically, URIs, HTTP verbs, HTTP response codes, and browser caches.</p>
<p>There's a problem, though, at least if you ask a REST purist. Nobody uses it "correctly".<sup class="footnote-ref" id="fnref-1"><a href="index.html#fn-1">1</a></sup> <sup class="footnote-ref" id="fnref-2"><a href="index.html#fn-2">2</a></sup> You're technically not REST unless you're using HATEOAS.</p>
<h2 id="only-love-can-conquer-hateoas">Only love can conquer HATEOAS</h2>
<p>Hypermedia as the engine of application state, or HATEOAS. The name that just rolls off the tongue.</p>
<p>I'm not going to explain it in extreme detail here, but the idea, roughly, is that your API returns JSON objects that look like this:</p>
<div class="highlight"><pre class="json"><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;author&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;firstName&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Stephen&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;lastName&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;King&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;birthday&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1947-09-21T05:00:00.000Z&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;links&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;books&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/authors/123/books&quot;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>A given model contains all the information you'd expect, plus a <code>links</code> (or <code>_links</code> in some implementations) object containing the URIs of various related models.</p>
<p>Honestly, at first blush, this seems like a really reasonable way to do things. It could benefit from some kind of library or something to automatically parse these things, but it's simple enough that almost any developer could probably roll their own.</p>
<p>However, there's at least one glaring flaw to me where the rubber meets the road, and it's when you need to traverse more than one relationship in the graph.</p>
<p>Suppose, for example, my front-end is consuming an API like the one that would generate that Stephen King model above. I want to get a list of publishers who have published Stephen King's books. Imagine the <code>book</code> model looks like this:</p>
<div class="highlight"><pre class="json"><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;book&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">720</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;title&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;The Dead Zone&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;pages&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">428</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;publicationDate&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;1979-08-30T05:00:00.000Z&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;isbn&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;978-0-670-26077-5&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;links&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;author&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/authors/123&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;publisher&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/publishers/902&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>What I can do is request all of King's books with <code>GET /authors/123/books</code> and then call a <code>GET</code> on the <code>publisher</code> link for each <code>book</code>.</p>
<p>However, subjectively speaking, this sucks. I don't know if you've ever had to work with an app that works this way, but it's a bad time for users. Best case scenario, this is going to take a lot of time and a lot of bandwidth due to the overhead of making one API per book. Even with HTTP/3 or whatever, where HTTP is no longer one transaction per connection. And the browser is going to choke if you fire off dozens of AJAX<sup class="footnote-ref" id="fnref-3"><a href="index.html#fn-3">3</a></sup> requests at once.<sup class="footnote-ref" id="fnref-4"><a href="index.html#fn-4">4</a></sup></p>
<p>Okay, okay. I know that what I described is a ridiculous approach that I definitely have never seen in the wild, much less worked on an app that does it. What we'd actually do is add a new link to the <code>author</code> model that does the relational hop for us on the back-end and return the results we want. Something like <code>/author/123/publishers</code>.</p>
<p>I don't know about you, but I hate adding boilerplate endpoints to apps. Seems like something metaprogramming would handle for you. There would need to be some guidelines from the programmer, though. If I just gave the program my database and told it to figure it out, I'd end up with technically valid but meaningless relationships.<sup class="footnote-ref" id="fnref-5"><a href="index.html#fn-5">5</a></sup> Not to mention the cycles.</p>
<p>What I find myself describing almost exists already, but it's not HATEOAS. It's GraphQL.</p>
<p>I know there are a lot of GraphQL haters out there. And I totally understand. It's not as simple to add GraphQL to an app as it is to incrementally add endpoints that speak JSON. Most GraphQL implementations, both front-end and back-end, are heavy-weight dependencies. And GraphQL itself is not a panacea for the problem of connecting front-end and back-end.</p>
<p>I've used GraphQL a few times in my career. Never for anything that's Serious Business‚Ñ¢Ô∏è. One time was in a Rails app. Another time was with Gatsby.</p>
<p>What impressed me most about using it was the quality of the developer experience. Once you set up your models, querying data was a breeze. Introspection, auto-completion, and type inference made writing queries a joy. Having your data query live in the same file as your display logic was the same kind of revelation as when React gave us JSX and our templates could live with the display logic. It's a code locality win.</p>
<p>Combine that with Prisma's tooling<sup class="footnote-ref" id="fnref-6"><a href="index.html#fn-6">6</a></sup> on the back-end and the need to write boilerplate endpoints virtually disappears.</p>
<p>GraphQL also solves the problem of data validation and sanitation, which HATEOAS doesn't address. Neither solves the problem of authorization, though. My point is that metaprogramming can't account for all the drudgery associated with a CRUD back-end.</p>
<h2 id="the-other-hateoas">The <em>other</em> HATEOAS</h2>
<p>Let's get pedantic for a second. I talked about HATEOAS and I gave an example using JSON. The example I gave is an example of HATEOAS, but it's just one implementation. The most important word in HATEOAS is "hypermedia". The JSON examples I gave qualify as hypermedia because they have links.</p>
<p>You know what else qualifies as hypermedia? The OG, HTML! Hyper text markup language.</p>
<p>There are some folks who have made various tools exploring this idea of HTML as HATEOAS. Their latest creation is <a href="https://htmx.org/">HTMX</a>.</p>
<p>I think it would be worth trying to create a web application using HTMX. The problem is, it bucks the trends of Big JavaScript‚Ñ¢Ô∏è.</p>
<p>You can have the things that make development easier:</p>
<ul>
<li>Templates and display logic live together</li>
<li>Data queries and display logic live together</li>
<li>No more endpoint boilerplate hell... maybe?</li>
</ul>
<p>The catch is, you'll be going back to rendering your HTML on the server side. But at least you don't have to render <em>entire</em> pages per request. You can absolutely return page fragments that get inserted into an existing page.<sup class="footnote-ref" id="fnref-7"><a href="index.html#fn-7">7</a></sup></p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>I don't mean to be overly critical of the web dev hippies out there. I see you. I love you. I agree with you most of the time.</p>
<p>I am critical of JSON HATEOAS implementations. Without some kind of tools for metaprogramming, I've found it leads to boilerplate fatigue. I don't enjoy churning out CRUD endpoints. I also hate when adding a new endpoint leads to a large impact radius in the code. Adding one new model, for example, is one thing. But then I have to modify all the endpoints of all the other models that contain relationships to the new endpoint that I want to utilize.</p>
<p>I don't think JSON HATEOAS implementations are inherently bad. How can they be? They're implementations. I don't think hypermedia is bad. How could I? The whole web is built on it. I do think that hypermedia is often an inappropriate medium to drive some of the applications we use it for. But, to its credit, hypermedia is adaptable enough that we can usually bend it into something resembling the shape we desire.</p>
<p>I have found that GraphQL, as a query language, seems a lot more powerful than JSON HATEOAS implementations to quickly produce maintainable web applications. But it's mostly due to the quality of its assistive tools. If I had to write GraphQL queries by hand with nothing to help me, I would probably be complaining about it, too.</p>
<hr/>
<section class="footnotes">
<ol>
<li id="fn-1"><p>REST is an architectural style, not a standard. Therefore, "correctness" is up to interpretation.<a class="footnote" href="index.html#fnref-1">‚Ü©</a></p></li>
<li id="fn-2"><p>"Correct" REST can be pretty controversial. For example, server-side sessions are technically disallowed, whether that means using a session ID in a cookie or as part of the URI. This is because sessions introduce state, whereas REST is supposed to be stateless. Also, sessions mean there is data which is opaque to the user, which is deemed a security and privacy risk. But what's the alternative? Sending credentials along with every request that needs it seems less secure to me (assuming sessions are implemented securely, which is a <em>big</em> assumption, I know). JSON Web Tokens are not opaque, for better or worse, but it's considered better practice to prefer a session token for systems where the application server <em>is</em> the authentication authority.<a class="footnote" href="index.html#fnref-2">‚Ü©</a></p></li>
<li id="fn-3"><p>It's 2023. Are we still calling this AJAX? This is just how the web works now, right? ü§∑<a class="footnote" href="index.html#fnref-3">‚Ü©</a></p></li>
<li id="fn-4"><p>Ask me how I know.<a class="footnote" href="index.html#fnref-4">‚Ü©</a></p></li>
<li id="fn-5"><p>My library card catalog example is too simple for an example, but anyone who has worked with a production database knows what I'm talking about.<a class="footnote" href="index.html#fnref-5">‚Ü©</a></p></li>
<li id="fn-6"><p>I'm not a fan of ORMs generally, but I've found Ecto and Prisma to be the least objectionable in my experience so far. Neither is perfect, but I'm particularly impressed by Prisma's tooling, which generates Typescript types for your database models. We need more metaprogramming tools like this.<a class="footnote" href="index.html#fnref-6">‚Ü©</a></p></li>
<li id="fn-7"><p>I haven't tried this myself yet, but I'm very intrigued by the concept. The ultimate would be if all response bodies are complete HTML pages. I'm not sure how that would work. Iframes everywhere seems too heavy. It just feels weird to me to return HTML <em>fragments</em> from a back-end.<a class="footnote" href="index.html#fnref-7">‚Ü©</a></p></li>
</ol>
</section>
</content>



    <p class="tags">
    
    </p>

    
    <small>
    <form id="upvote-form" action="https://jaysherby.com/upvote/37033/" method="post" style="display: inline">
        <input hidden name="pk" value="37033" style="display:none"/>
        <input hidden name="title" style="display:none"/>
        
        <button>‚ñµ Toast this post</button>
        
    </form>
    - <small class="upvote-count">1 toast</small>
</small>
<script>
    document.querySelector('#upvote-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const form = e.target;
        fetch(form.action, {
            method: form.method,
            body: new FormData(form),
        });
        const button = form.querySelector('button')
        button.disabled = true
        button.innerText = "‚ñµ Toasted"
        const upvoteCount = document.querySelector('.upvote-count')
        upvoteCount.innerHTML = `${(parseInt(upvoteCount.innerHTML.split(" ")[0]) + 1)} toasts`
    });
</script>
    



  </main>
  <footer style="padding:25px 0;">
    

<span>
    Made with <a href="https://bearblog.dev">Bear  ï‚Ä¢·¥•‚Ä¢ î</a>
</span>

    <style>
      body:hover {
        border-image: url("https://jaysherby.com/hit/37033");
        border-width: 0;
      }
    </style>
  </footer>
</body>
</html>